diff --git a/includes/registration.entity.inc b/includes/registration.entity.inc
old mode 100644
new mode 100755
index 083e7ac..7d9d639
--- a/includes/registration.entity.inc
+++ b/includes/registration.entity.inc
@@ -9,7 +9,7 @@
  * Implements hook_entity_info().
  */
 function registration_entity_info() {
-  return array(
+  $entities = array(
     'registration' => array(
       'module' => 'registration',
       'label' => t('Registration'),
@@ -24,15 +24,7 @@ function registration_entity_info() {
       'bundle keys' => array(
         'bundle' => 'type',
       ),
-      'bundles' => array(
-        'registration' => array(
-          'label' => 'Registration',
-          'admin' => array(
-            'path' => 'admin/structure/registration/manage',
-            'access arguments' => array('administer registration'),
-          ),
-        ),
-      ),
+      'bundles' => array(),
       'view modes' => array(
         'full' => array(
           'label' => t('Full Registration'),
@@ -43,11 +35,23 @@ function registration_entity_info() {
       'token type' => 'registration',
     ),
   );
+
+  foreach (registration_entity_types() as $type => $info) {
+    $entities['registration']['bundles'][$type] = array(
+      'label' => $info->name,
+      'admin' => array(
+        'path' => 'admin/structure/registration/types/manage/' . $info->type,
+        'access arguments' => array('administer registration'),
+      ),
+    );
+  }
+
+  return $entities;
 }
 
 function registration_uri($registration) {
   return array(
-    'path' => 'registration/' . $registration->id,
+    'path' => 'registration/' . $registration->registration_id,
   );
 }
 
@@ -60,9 +64,7 @@ class RegistrationEntityClass extends Entity {
     parent::__construct($values, 'registration');
   }
 
-  /**
-   * Override buildContent() to add registration properties.
-   */
+  // Override buildContent() to add registration properties.
   public function buildContent($view_mode = 'full', $langcode = NULL) {
     // invoke theme handler to return markup for registration properties
     $content['registration'] = array(
@@ -93,17 +95,45 @@ function registration_entity_property_info_alter(&$info) {
     'type' => 'date',
     'schema field' => 'updated',
   );
-  $properties['nid'] = array(
-    'label' => t("Node"),
-    'description' => t("The node this registration is associated with."),
-    'type' => 'node',
-    'schema field' => 'nid',
-  );
 
   return $info;
 }
 
 /**
+ * Returns all the bundles for the registration entity.
+ */
+function registration_entity_types() {
+  $types = &drupal_static(__FUNCTION__);
+  if (empty($types)) {
+    // types array is empty, so lets load it
+    $types = array();
+
+    $tq = db_select('registration_type', 'rt')->fields('rt')->execute();
+    foreach ($tq as $row) {
+      $types[$row->type] = $row;
+    }
+  }
+  return $types;
+}
+
+/**
+ * Resets the cached list of registration types.
+ */
+function registration_entity_types_reset() {
+  $registration_types = &drupal_static('registration_entity_types');
+  $registration_types = NULL;
+}
+
+/**
+ * Loads a registration type.
+ */
+function registration_type_load($type) {
+  $types = registration_entity_types();
+  $type = str_replace('-', '_', $type);
+  return isset($types[$type]) ? $types[$type] : FALSE;
+}
+
+/**
  * Loads a registration by ID.
  */
 function registration_load($registration_id) {
@@ -174,23 +204,26 @@ function registration_save($registration) {
  * Implements hook_field_extra_fields().
  */
 function registration_field_extra_fields() {
-  // expose the email property on the fields and display settings forms.
-  $extra['registration']['registration'] = array(
-    'form' => array(
-      'mail' => array(
-        'label' => t('Email'),
-        'description' => t('Registrant\'s email address.'),
-        'weight' => 0,
+  $extra = array();
+
+  foreach (registration_entity_types() as $type => $reg_type) {
+    $extra['registration'][$type] = array(
+      'form' => array(
+        'email' => array(
+          'label' => t('Email'),
+          'description' => t('Registration module email form element'),
+          'weight' => -5,
+        ),
       ),
-    ),
-    'display' => array(
-      'mail' => array(
-        'label' => t('Email'),
-        'description' => t('Registrant\'s email address.'),
-        'weight' => 0,
+      'display' => array(
+        'email' => array(
+          'label' => t('Email'),
+          'description' => t("Registered User's Email Address"),
+          'weight' => -5,
+        ),
       ),
-    )
-  );
+    );
+  }
 
   return $extra;
-}
+}
\ No newline at end of file
diff --git a/includes/registration.forms.inc b/includes/registration.forms.inc
old mode 100644
new mode 100755
index 57b95be..156d58c
--- a/includes/registration.forms.inc
+++ b/includes/registration.forms.inc
@@ -1,41 +1,45 @@
 <?php
+/**
+ * @file
+ *  Contains form definitions and handlers for Registration.
+ */
 
 /**
  * Form callback: create or edit a contact.
  *
  * @param $contact
  *   The contact object to edit or for a create form an empty contact object
- *     with only a contact type defined.
+ *   with only a contact type defined.
  */
-function registration_form($form, &$form_state, $registration) {
+function registration_form($form, &$form_state, $registration, $entity, $type) {
   $form_state['registration'] = $registration;
+  $form_state['entity'] = $entity;
+  $form_state['entity_type'] = $type;
+  
+  $data = entity_extract_ids($type, $entity);
 
-  // default email from existing registraiton or authenticated user
-  global $user;
-  $mail = '';
-  if (isset($registration->registration_id)) {
-    $mail = $registration->mail;
-  }
-  else if ($user->uid) {
-    $mail = $user->mail;
-  }
+  $entity_info = array(
+    'id' => $data[0],
+    'type' => $type,
+    'bundle' => $data[2],
+  );
 
   global $user;
-  $form['mail'] = array(
+  $form['email'] = array(
     '#type' => 'textfield',
     '#title' => t('Email'),
     '#description' => t('The email to associate with this registration.'),
-    '#default_value' => $mail,
+    '#default_value' => $user->uid ? $user->mail : '',
     '#size' => 40,
     '#maxlength' => 255,
     '#required' => TRUE,
   );
 
-  $settings  = registration_node_settings($registration->nid);
+  $settings  = registration_entity_settings($entity_info);
   $capacity  = $settings['capacity'];
   $remaining = 20;
   if ($capacity) {
-    $remaining = $capacity - registration_event_count($registration->nid);
+    $remaining = $capacity - registration_event_count($entity_info);
   }
   $options = array();
   for ($i = 1; $i < $remaining + 1; $i++) {
@@ -47,8 +51,8 @@ function registration_form($form, &$form_state, $registration) {
     '#description' => t('Select the number of registrations you want to create.'),
     '#options' => $options,
     '#default_value' => 1,
-    '#access' => isset($settings['settings']['multiple_registrations']) ? 
-        $settings['settings']['multiple_registrations'] : FALSE
+    '#access' => isset($settings['multiple_registrations']) ?
+        $settings['multiple_registrations'] : FALSE,
   );
 
 
@@ -61,7 +65,14 @@ function registration_form($form, &$form_state, $registration) {
   );
 
   // add a delete button for existing registration
-  if (isset($registration->registration_id) &&
+  if (isset($registration->registration_id)) {
+    $form['actions']['delete'] = array(
+      '#type' => 'submit',
+      '#value' => t('Delete'),
+    );
+  }
+
+  if (!empty($registration->registration_id) &&
     user_access('administer registration')
   ) {
     $form['actions']['delete'] = array(
@@ -74,7 +85,7 @@ function registration_form($form, &$form_state, $registration) {
   $form['actions']['cancel'] = array(
     '#type' => 'link',
     '#title' => t('Cancel'),
-    '#href' => 'node/' . $registration->nid,
+    '#href' => 'node/' . $data[0],
   );
 
   return $form;
@@ -84,32 +95,30 @@ function registration_form($form, &$form_state, $registration) {
  * Validation callback for registration_form().
  */
 function registration_form_validate($form, &$form_state) {
+  $entity = $form_state['entity'];
+  $type = $form_state['entity_type'];
   $registration = $form_state['registration'];
-
+  $data = entity_extract_ids($type, $entity);
+  $entity_info = array(
+    'id' => $data[0],
+    'type' => $type,
+    'bundle' => $data[2],
+  );
   // verify the event hasn't sold out
-  if (!registration_has_room($registration->nid)) {
+  if (!registration_has_room($entity_info)) {
     drupal_set_message(t('Sorry, this event has sold out during your registration.'));
   }
 
   // validate email address
-  if (!valid_email_address($form_state['values']['mail'])) {
-    form_set_error('mail', t('The email address is invalid.'));
+  if (!valid_email_address($form_state['values']['email'])) {
+    form_set_error('email', t('The email address is invalid.'));
   }
-  // check for duplicate registrations
+  // @TODO check for duplicate registrations
   else {
-    $query = db_select('registration', 'r')
-      ->condition('nid', $registration->nid)
-      ->condition('mail', $form_state['values']['mail']);
-    
-    // exclude existing registration
-    if (isset($registration->registration_id)) {
-      $query->condition('registration_id', $registration->registration_id, '<>');
-    }
-
-    $count = $query->countQuery()->execute()->fetchField();   
+    $count = 0;
     if ($count > 0) {
-      form_set_error('mail', t('%mail is already registered for this event.', 
-        array('%mail' => $form_state['values']['mail'])));
+      form_set_error('email', t('%mail is already registered for this event.',
+        array('%mail' => $form_state['values']['email'])));
     }
   }
 
@@ -121,25 +130,27 @@ function registration_form_validate($form, &$form_state) {
  * Submit callback for registration_form().
  */
 function registration_form_submit($form, &$form_state) {
+  $entity = $form_state['entity'];
+  $type = $form_state['entity_type'];
   $registration = $form_state['registration'];
+  $data = entity_extract_ids($type, $entity);
 
   // Set the contact's author uid
   global $user;
   $registration->author_uid = $user->uid;
-  $registration->mail = $form_state['values']['mail'];
+  $email = $form_state['values']['email'];
   $registration->count = $form_state['values']['count'];
 
   // Notify field widgets.
   field_attach_submit('registration', $registration, $form, $form_state);
 
-  // Save the registration and redirect to the associated node.
+  // Save the registration and redirect to the tour node.
   if (registration_save($registration)) {
     drupal_set_message(t('Thanks you, your registration has been recieved!'));
-    $form_state['redirect'] = 'node/' . $registration->nid;
+    $form_state['redirect'] = 'node/' . $data[0];
   }
   else {
-    drupal_set_message(t('Sorry, there has been a problem submitting your 
-        registration.'));
+    drupal_set_message(t('Sorry, there has been a problem submitting your registration.'));
   }
 }
 
@@ -197,7 +208,7 @@ function registration_delete_confirm_submit($form, &$form_state) {
  */
 function registration_registrations_broadcast_form($form, &$form_state, $node) {
   $form_state['node'] = $node;
-  
+
   $form['subject'] = array(
     '#type' => 'textfield',
     '#title' => t('Subject'),
@@ -240,16 +251,25 @@ function registration_registrations_broadcast_form_submit($form, &$form_state) {
  * @param array $form_state
  * @param object $node
  */
-function registration_registrations_settings_form($form, &$form_state, $node) {
-  $form_state['nid'] = $node->nid;
-
-  $settings = registration_node_settings($node->nid);
+function registration_registrations_settings_form($form, &$form_state, $entity, $type) {
+  $form_state['entity'] = $entity;
+  $form_state['entity_type'] = $type;
+  
+  $data = entity_extract_ids($type, $entity);
+  
+  $entity_info = array(
+    'id' => $data[0],
+    'type' => $type,
+    'bundle' => $data[2],
+  );
 
+  $settings = registration_entity_settings($entity_info);
+  
   $form['status'] = array(
     '#type' => 'checkbox',
     '#title' => t('Enable'),
     '#description' => t('Check to enable registrations for %name.',
-      array('%name' => $node->title)
+      array('%name' => $entity->title)
     ),
     '#default_value' => isset($settings['status']) ? $settings['status'] : -1,
   );
@@ -257,7 +277,7 @@ function registration_registrations_settings_form($form, &$form_state, $node) {
     '#type' => 'textfield',
     '#title' => t('Capacity'),
     '#description' => t('The maximum number of regsitrants for %name. Leave at 0
-        for no limit.', array('%name' => $node->title)),
+         for no limit.', array('%name' => $entity->title)),
     '#size' => 5,
     '#maxlength' => 10,
     '#required' => TRUE,
@@ -276,7 +296,7 @@ function registration_registrations_settings_form($form, &$form_state, $node) {
     '#description' => 'If checked, a reminder will be sent to registrants on the following date.',
     '#default_value' => isset($settings['send_reminder']) ? $settings['send_reminder'] : -1,
   );
-  
+
   $reminder_date = array();
   if (isset($settings['reminder_date'])) {
     $datetime = strtotime($settings['reminder_date']);
@@ -284,7 +304,7 @@ function registration_registrations_settings_form($form, &$form_state, $node) {
       'year' => date('Y', $datetime),
       'month' => date('n', $datetime),
       'day' => date('d', $datetime),
-    );    
+    );
   }
 
   $form['reminder']['reminder_settings'] = array(
@@ -296,12 +316,12 @@ function registration_registrations_settings_form($form, &$form_state, $node) {
         ':input[name="send_reminder"]' => array('checked' => TRUE),
       ),
     )
-  );  
+  );
   $form['reminder']['reminder_settings']['reminder_date'] = array(
     '#type' => 'date',
     '#title' => 'Reminder Date',
     '#default_value' => $reminder_date,
-  );  
+  );
   $form['reminder']['reminder_settings']['reminder_template'] = array(
     '#type' => 'textarea',
     '#title' => 'Template',
@@ -311,7 +331,7 @@ function registration_registrations_settings_form($form, &$form_state, $node) {
   // add token support
   if (module_exists('token')) {
     $form['reminder']['reminder_settings']['token_tree'] = array(
-      '#theme' => 'token_tree', 
+      '#theme' => 'token_tree',
       '#token_types' => array('node', 'content-type', 'current-page', 'registration'),
       '#global_types' => FALSE,
     );
@@ -322,24 +342,24 @@ function registration_registrations_settings_form($form, &$form_state, $node) {
     '#title' => t('Additional Settings'),
     '#collapsible' => TRUE,
     '#collapsed' => FALSE,
-    '#tree' => TRUE
+    '#tree' => TRUE,
   );
   $form['settings']['multiple_registrations'] = array(
     '#type' => 'checkbox',
     '#title' => t('Allow multiple registrations'),
     '#description' => t('If selected, users can register for more than one slot for this event.'),
-    '#default_value' => isset($settings['settings']['multiple_registrations']) ? $settings['settings']['multiple_registrations'] : -1,
+    '#default_value' => isset($settings['multiple_registrations']) ? $settings['multiple_registrations'] : -1,
   );
   $form['settings']['from_address'] = array(
     '#type' => 'textfield',
     '#title' => t('From Address'),
     '#description' => t('From email address to use for confirmations, reminders, and broadcast emails.'),
     '#required' => TRUE,
-    '#default_value' => isset($settings['settings']['from_address']) ? 
-        $settings['settings']['from_address'] : 
-        variable_get('site_mail', ini_get('sendmail_from')),
+    '#default_value' => isset($settings['from_address']) ?
+      $settings['from_address'] :
+      variable_get('site_mail', ini_get('sendmail_from')),
   );
-  
+
   $form['save'] = array(
     '#type' => 'submit',
     '#value' => t('Save Settings'),
@@ -360,11 +380,11 @@ function registration_registrations_settings_form_validate($form, &$form_state)
   if (!is_numeric($capacity) || ((int)$capacity != $capacity) || ($capacity < 0)) {
     form_set_error('capacity', t('Capacity must be a positive integer.'));
   }
-  
+
   // validate from address
   if (!valid_email_address($form_state['values']['settings']['from_address'])) {
     form_set_error('from', t('From email address is invalid.'));
-  } 
+  }
 }
 
 /**
@@ -374,17 +394,193 @@ function registration_registrations_settings_form_validate($form, &$form_state)
  * @param array $form_state
  */
 function registration_registrations_settings_form_submit($form, &$form_state) {
-  $nid = $form_state['nid'];
+  $entity = $form_state['entity'];
+  $type = $form_state['entity_type'];
+  $data = entity_extract_ids($type, $entity);
+  $info = array(
+    'id' => $data[0],
+    'type' => $type,
+    'bundle' => $data[2],
+  );
   $fields = array(
-    'status' => $form_state['values']['status'], 
-    'capacity' => $form_state['values']['capacity'], 
-    'send_reminder' => $form_state['values']['send_reminder'],
-    'settings' => serialize($form_state['values']['settings']),
+    'entity_id' => $data[0],
+    'entity_type' => $type,
+    'entity_bundle' => $data[2],
+    'settings' => array(
+      'status' => $form_state['values']['status'],
+      'capacity' => $form_state['values']['capacity'],
+      'send_reminder' => $form_state['values']['send_reminder'],
+    ) + $form_state['values']['settings'],
   );
   if ($form_state['values']['send_reminder']) {
-    $fields['reminder_date'] = $form_state['values']['reminder_date']['year'] . '-' . $form_state['values']['reminder_date']['month'] . '-' . $form_state['values']['reminder_date']['day'];
-    $fields['reminder_template'] = $form_state['values']['reminder_template'];
+    $fields['settings']['reminder_date'] = $form_state['values']['reminder_date']['year']
+      . '-' . $form_state['values']['reminder_date']['month']
+      . '-' . $form_state['values']['reminder_date']['day'];
+    $fields['settings']['reminder_template'] = $form_state['values']['reminder_template'];
   }
-  registration_update_node_settings($nid, $fields);
-  drupal_goto('node/' . $nid);
+  $fields['settings'] = serialize($fields['settings']);
+  registration_update_entity_settings($info, $fields);
 }
+
+/**
+ * Register button form callback.
+ *
+ * Shows a Register button for a registration enabled entity.
+ *
+ * If the user is already registered for this item, we instead show text to the
+ * user that they are already registered.
+ */
+function registration_register_form($form, &$form_state, $type, $bundle, $eid) {
+  global $user;
+  $form = array();
+  if ($user->uid != 0 && registration_check_email_registered($user->mail, $type, $bundle, $eid)) {
+    return array(
+      'already' => array(
+        '#type' => 'markup',
+        '#markup' => '<small>* ' . t('You are already registered for this item.') . ' *</small>',
+      ),
+    );
+  }
+  $form['eid'] = array(
+    '#type' => 'hidden',
+    '#value' => $eid,
+  );
+  $form['etype'] = array(
+    '#type' => 'hidden',
+    '#value' => $type,
+  );
+  $form['bundle'] = array(
+    '#type' => 'hidden',
+    '#value' => $bundle,
+  );
+  $form['submit'] = array(
+    '#type' => 'submit',
+    '#value' => 'Register',
+  );
+  return $form;
+}
+
+/**
+ * Register button form submit.
+ *
+ * Loads up the complete registration form for the entity.
+ */
+function registration_register_form_submit($form, &$form_state) {
+  drupal_goto('register/' . $form_state['values']['etype'] . '/' . $form_state['values']['bundle'] . '/' . $form_state['values']['eid']);
+}
+
+/**
+ * Registration form page title callback.
+ */
+function registration_register_entity_title($type, $bundle, $entityid) {
+  $entity = entity_load($type, array($entityid));
+  return t('Register for @title', array('@title' => $entity[$entityid]->title));
+}
+
+/**
+ * Form builder for registering for an entity. Adds bundle's fields to the form.
+ */
+function registration_register_entity_form($form, &$form_state, $type, $bundle, $entityid) {
+  $info = array(
+    'id' => $entityid,
+    'type' => $type,
+    'bundle' => $bundle,
+  );
+  $entity = registration_entity_registration_bundle($info);
+  $status = registration_entity_registration_status($info);
+  $form = array();
+  $form['entity_type'] = array(
+    '#type' => 'hidden',
+    '#value' => $type,
+  );
+  $form['entity_bundle'] = array(
+    '#type' => 'hidden',
+    '#value' => $bundle,
+  );
+  $form['entity_id'] = array(
+    '#type' => 'hidden',
+    '#value' => $entityid,
+  );
+  if ($status == 0) {
+    $form += array(
+      'invalid' => array(
+        '#type' => 'markup',
+        '#markup' => t('This item is not accepting registrations at this time.'),
+      ),
+      'actions' => array(
+        '#type' => 'actions',
+        'goback' => array(
+          '#type' => 'button',
+          '#value' => t('Go Back'),
+        ),
+      ),
+    );
+    return $form;
+  }
+  if (is_string($entity)) {
+    $etype = $entity;
+    $entity = entity_create('registration', array('type' => $etype));
+    $entity->entity_type = $type;
+    $entity->entity_bundle = $bundle;
+    $entity->eid = $entityid;
+    $form['registration'] = array(
+      '#type' => 'fieldset',
+      '#title' => 'Registration Information',
+    );
+    $form['registration']['entity'] = array(
+      '#type' => 'value',
+      '#value' => $entity,
+    );
+    $form['registration']['email'] = array(
+      '#type' => 'textfield',
+      '#text_format' => 'email_default',
+      '#title' => 'Email Address',
+      '#required' => TRUE,
+    );
+    $form['actions'] = array(
+      '#type' => 'actions',
+      'cancel' => array(
+        '#type' => 'button',
+        '#value' => t('Cancel'),
+      ),
+      'submit' => array(
+        '#type' => 'submit',
+        '#value' => t('Submit Registration'),
+      ),
+    );
+    field_attach_form('registration', $entity, $form['registration'], $form_state);
+    return $form;
+  }
+}
+
+/**
+ * Registration form validation callback.
+ */
+function registration_register_entity_form_validate($form, &$form_state) {
+  $entityid = $form_state['values']['entity_id'];
+  $entitytype = $form_state['values']['entity_type'];
+  $entitybundle = $form_state['values']['entity_bundle'];
+  $registration = $form_state['values']['entity'];
+  field_attach_form_validate('registration', $registration, $form, $form_state);
+  return TRUE;
+}
+
+/**
+ * Registration form submit callback.
+ */
+function registration_register_entity_form_submit($form, &$form_state) {
+  global $user;
+  $entityid = $form_state['values']['entity_id'];
+  $entitytype = $form_state['values']['entity_type'];
+  $entitybundle = $form_state['values']['entity_bundle'];
+  $registration = $form_state['values']['entity'];
+  $registration->created = REQUEST_TIME;
+  $registration->updated = REQUEST_TIME;
+  $registration->user_uid = $user->uid;
+  $registration->author_uid = $user->uid;
+  $registration->status = 1;
+  entity_save('registration', $registration);
+  field_attach_submit('registration', $registration, $form['registration'], $form_state);
+  drupal_set_message(t('Your registration has been received.'));
+  drupal_goto($entitytype . '/' . $entityid);
+}
\ No newline at end of file
diff --git a/registration.info b/registration.info
old mode 100644
new mode 100755
index cbaa7fd..61c5d35
--- a/registration.info
+++ b/registration.info
@@ -6,4 +6,6 @@ core = 7.x
 dependencies[] = entity
 
 files[] = includes/registration.entity.inc
-files[] = includes/registration.forms.inc
\ No newline at end of file
+files[] = includes/registration.forms.inc
+files[] = includes/registration.admin.inc
+files[] = includes/registration.theme.inc
\ No newline at end of file
diff --git a/registration.install b/registration.install
old mode 100644
new mode 100755
index d9a8e47..4ecffa6
--- a/registration.install
+++ b/registration.install
@@ -25,7 +25,19 @@ function registration_schema() {
         'not null' => TRUE,
         'default' => '',
       ),
-      'nid' => array(
+      'entity_type' => array(
+        'description' => 'The entity type that this registration is tied to.',
+        'type' => 'varchar',
+        'length' => 100,
+        'not null' => TRUE,
+      ),
+      'entity_bundle' => array(
+        'description' => 'The entity bundle that this registration is tied to.',
+        'type' => 'varchar',
+        'length' => 100,
+        'not null' => TRUE,
+      ),
+      'eid' => array(
         'description' => 'The id of the entity this registration is associated with.',
         'type' => 'int',
         'not null' => TRUE,
@@ -62,6 +74,12 @@ function registration_schema() {
         'not null' => TRUE,
         'default' => 0,
       ),
+      'status' => array(
+        'description' => 'The status of this registration.',
+        'type' => 'int',
+        'not null' => TRUE,
+        'default' => 0,
+      ),
     ),
     'indexes' => array(
       'registration_updated' => array('updated'),
@@ -79,8 +97,8 @@ function registration_schema() {
       ),
     ),
     'unique keys' => array(
-      'nid_mail' => array('nid', 'mail'), 
-    ), 
+      'eid_mail' => array('eid', 'mail'),
+    ),
     'primary key' => array('registration_id'),
   );
 
@@ -122,7 +140,7 @@ function registration_schema() {
         'type' => 'text',
         'size' => 'big',
         'not null' => FALSE,
-      ),  
+      ),
       'settings' => array(
         'type' => 'blob',
         'not null' => TRUE,
@@ -140,6 +158,77 @@ function registration_schema() {
     'primary key' => array('nid'),
   );
 
+  $schema['registration_type'] = array(
+    'description' => 'Registration entity types.',
+    'fields' => array(
+      'type' => array(
+        'description' => 'Bundle (machine name) of the registration entity.',
+        'type' => 'varchar',
+        'length' => '50',
+        'not null' => TRUE,
+      ),
+      'name' => array(
+        'description' => 'Human readable name of the registration entity.',
+        'type' => 'varchar',
+        'length' => '100',
+        'not null' => TRUE,
+      ),
+      'description' => array(
+        'description' => 'Description of the registration entity.',
+        'type' => 'text',
+      ),
+      'created' => array(
+        'description' => 'Unix timestamp of creation date.',
+        'type' => 'int',
+        'not null' => TRUE,
+        'default' => 0,
+      ),
+      'changed' => array(
+        'description' => 'Unix timestamp of changed date.',
+        'type' => 'int',
+        'not null' => TRUE,
+        'default' => 0,
+      ),
+    ),
+    'primary key' => array('type'),
+  );
+
+  $schema['registration_attach'] = array(
+    'description' => 'Registration bundles associated to specific entities.',
+    'fields' => array(
+      'entity_id' => array(
+        'description' => 'Entity ID our registration bundle is attached to.',
+        'type' => 'int',
+        'not null' => TRUE,
+      ),
+      'entity_type' => array(
+        'description' => 'Entity type our registration bundle is attached to.',
+        'type' => 'varchar',
+        'length' => 255,
+        'not null' => TRUE,
+      ),
+      'entity_bundle' => array(
+        'description' => 'Entity bundle our registration bundle is attached to.',
+        'type' => 'varchar',
+        'length' => 255,
+        'not null' => TRUE,
+      ),
+      'registration_bundle' => array(
+        'description' => 'The registration bundle we are attaching.',
+        'type' => 'varchar',
+        'length' => 255,
+        'not null' => TRUE,
+      ),
+      'settings' => array(
+        'description' => 'Serialized object of our registration settings.',
+        'type' => 'text',
+        'size' => 'big',
+        'not null' => TRUE,
+        'serialize' => TRUE,
+      ),
+    ),
+    'primary key' => array('entity_id', 'entity_type', 'entity_bundle'),
+  );
+
   return $schema;
 }
-
diff --git a/registration.module b/registration.module
old mode 100644
new mode 100755
index 75d2aa4..7360621
--- a/registration.module
+++ b/registration.module
@@ -8,22 +8,90 @@
 module_load_include('inc', 'registration', 'includes/registration.entity');
 
 /**
+ * Implements hook_menu_alter().
+ *
+ * Set all manage field and display links to inline context so they don't show
+ * up on the Types page.
+ */
+function registration_menu_alter(&$items) {
+  foreach (registration_entity_types() as $type => $info) {
+    $items['admin/structure/registration/types/manage/' . $type . '/fields']['context'] = MENU_CONTEXT_INLINE;
+    $items['admin/structure/registration/types/manage/' . $type . '/display']['context'] = MENU_CONTEXT_INLINE;
+  }
+}
+
+/**
  * Implements hook_menu().
  */
 function registration_menu() {
-  $items['admin/structure/registration/manage'] = array(
+  $items['admin/structure/registration'] = array(
     'title' => 'Registration',
-    'description' => 'Manage Registration structure',
+    'description' => 'Manage Registration settings and types',
+    'access arguments' => array('administer registration'),
     'page callback' => 'registration_admin_page',
+    'file' => 'includes/registration.admin.inc',
+  );
+  $items['admin/structure/registration/status/%/%'] = array(
+    'title' => 'Enable Registrations',
+    'title callback' => 'registration_admin_form_title',
+    'title arguments' => array(4, 'Status', 5),
+    'page callback' => 'drupal_get_form',
+    'page arguments' => array('registration_status_form', 4, 5),
     'access arguments' => array('administer registration'),
-    
+    'file' => 'includes/registration.admin.inc',
   );
-  $items['admin/structure/registration/manage/settings'] = array(
+  $items['admin/structure/registration/settings'] = array(
     'title' => 'Settings',
-    'description' => 'Manage Registration settings',
+    'description' => 'Manage Registration settings and types',
+    'access arguments' => array('administer registration'),
+    'page callback' => 'registration_admin_page',
+    'file' => 'includes/registration.admin.inc',
     'type' => MENU_DEFAULT_LOCAL_TASK,
   );
-
+  $items['admin/structure/registration/types'] = array(
+    'title' => 'Types',
+    'description' => 'Manage Registration Types',
+    'type' => MENU_LOCAL_TASK,
+    'page callback' => 'registration_types_page',
+    'access arguments' => array('administer registration'),
+    'file' => 'includes/registration.admin.inc',
+  );
+  $items['admin/structure/registration/types/add'] = array(
+    'title' => 'Add a Registration Type',
+    'type' => MENU_LOCAL_ACTION,
+    'page callback' => 'drupal_get_form',
+    'page arguments' => array('registration_type_form'),
+    'access arguments' => array('administer registration'),
+    'file' => 'includes/registration.admin.inc',
+  );
+  $items['admin/structure/registration/types/manage/%'] = array(
+    'title' => 'Edit Registration Type',
+    'title callback' => 'registration_admin_form_title',
+    'title arguments' => array(5, 'Edit'),
+    'file' => 'includes/registration.admin.inc',
+    'page callback' => 'drupal_get_form',
+    'page arguments' => array('registration_type_form', 5),
+    'access arguments' => array('administer registration'),
+    'type' => MENU_CALLBACK,
+  );
+  $items['admin/structure/registration/types/%/delete'] = array(
+    'title' => 'delete',
+    'title callback' => 'registration_admin_form_title',
+    'title arguments' => array(4, 'Delete'),
+    'page callback' => 'drupal_get_form',
+    'page arguments' => array('registration_delete_type_form', 4),
+    'access arguments' => array('administer registration'),
+    'type' => MENU_CALLBACK,
+    'file' => 'includes/registration.admin.inc',
+  );
+  $items['register/%/%/%'] = array(
+    'title callback' => 'registration_register_entity_title',
+    'title arguments' => array(1, 2, 3),
+    'page callback' => 'drupal_get_form',
+    'file' => 'includes/registration.forms.inc',
+    'page arguments' => array('registration_register_entity_form', 1, 2, 3),
+    'access arguments' => array('add registration'),
+  );
   $items['registration/%registration'] = array(
     'title callback' => 'registration_page_title',
     'title arguments' => array(1),
@@ -59,7 +127,7 @@ function registration_menu() {
   $items['node/%node/register'] = array(
     'title' => 'Register',
     'page callback' => 'registration_register_page',
-    'page arguments' => array(1),
+    'page arguments' => array(1, 'node'),
     'access callback' => 'registration_register_page_access',
     'access arguments' => array(1),
     'file' => 'includes/registration.forms.inc',
@@ -84,7 +152,7 @@ function registration_menu() {
   $items['node/%node/registrations/settings'] = array(
     'title' => 'Settings',
     'page callback' => 'drupal_get_form',
-    'page arguments' => array('registration_registrations_settings_form', 1),
+    'page arguments' => array('registration_registrations_settings_form', 1, 'node'),
     'access callback' => 'registration_administer_registrations_access',
     'access arguments' => array(1),
     'file' => 'includes/registration.forms.inc',
@@ -109,47 +177,60 @@ function registration_menu() {
  * Implements hook_permission().
  */
 function registration_permission() {
-  return array(
+  $perms = array(
     'administer registration' => array(
       'title' => t('Administer registration'),
       'description' => t('Perform administration tasks for Registrations.'),
       'restrict access' => TRUE,
     ),
-    'view registration' => array(
-      'title' => t('View registrations'),
+    'view any registration' => array(
+      'title' => t('View any registration'),
     ),
-    'add registration' => array(
-      'title' => t('Add registrations'),
+    'add any registration' => array(
+      'title' => t('Add any registration'),
     ),
   );
+
+  foreach (registration_entity_types() as $type => $info) {
+    $perms['create ' . $type . ' registration'] = array(
+      'title' => t('Create <em>@name</em> registrations', array('@name' => $info->name)),
+    );
+    $perms['edit ' . $type . ' registration'] = array(
+      'title' => t('Edit <em>@name</em> registrations', array('@name' => $info->name)),
+    );
+    $perms['delete ' . $type . ' registration'] = array(
+      'title' => t('Delete <em>@name</em> registrations', array('@name' => $info->name)),
+    );
+    $perms['view ' . $type . ' registration'] = array(
+      'title' => t('View <em>@name</em> registrations', array('@name' => $info->name)),
+    );
+  }
+
+  return $perms;
 }
 
 /**
- * Landing page for managing the structure of registrations.
+ * Implements hook_entity_view_alter().
  */
-function registration_admin_page() {
-  $rows = array();
-  foreach (node_type_get_names() as $type => $name) {
-    $rows[] = array(
-      l($name, 'admin/structure/types/manage/' . $type),
-      (variable_get('registration_node_status_' . $type, 0)) ? t('Enabled') :
-      t('Disabled'),
-    );
+function registration_entity_view_alter(&$build, $type) {
+  $types_to_alter = array();
+  $types_to_alter_query = db_select('variable', 'v')->fields('v')->condition('name', 'registration_bundle:%', 'LIKE')->execute();
+  foreach ($types_to_alter_query as $row) {
+    $mtype = $row->name;
+    $mtype = substr($mtype, 20);
+    $types_to_alter[] = $mtype;
   }
+  if (in_array($type . ':_' . $build['#bundle'], $types_to_alter)) {
+    // the type is in the types of entities to alter for registrations
+    if (!function_exists('registration_register_form')) {
+      module_load_include('inc', 'registration', 'includes/registration.forms');
+    }
+    $build['registration_register_form'] = drupal_get_form('registration_register_form', $type, $build['#bundle'], $build['#node']->nid);
+  }
+}
 
-  $table = array(
-    'header' => array(t('Content type'), t('Registration status')),
-    'rows' => $rows,
-  );
-  $out = theme('table', $table);
-
-  return t('The following table lists the registration status for each content 
-    type. You can enable/disable registrations from the content type settings 
-    page. You can also !manage_fields and their !display_settings.', 
-    array(
-      '!manage_fields' => l('manage registration fields', 'admin/structure/registration/manage/fields'),
-      '!display_settings' => l('display settings', 'admin/structure/registration/manage/display'),
-    )) . $out;
+function registration_check_email_registered($email, $entity_type, $entity_bundle, $entity_id) {
+  return FALSE;
 }
 
 /**
@@ -163,17 +244,20 @@ function registration_page_view($registration, $view_mode = 'full') {
  * Page title callback.
  */
 function registration_page_title($registration) {
-  // use the node title in the registration page title
-  if ($node = node_load($registration->nid)) {
-    return t('Registration for @title', array('@title' => $node->title));
-  }
+  $entity = entity_load($registration->entity_type, array($registration->eid));
+  $entity = $entity[$registration->eid];
+  return t('Registration #@num for @entity', array('@num' => $registration->registration_id, '@entity' => $entity->title));
 }
 
 /**
  * Implements hook_form_FORM_ID_alter().
- *   Add registration options to node type form.
+ *
+ * Add registration options to node type form.
  */
 function registration_form_node_type_form_alter(&$form, &$form_state) {
+  if (!function_exists('registration_bundle_options')) {
+    module_load_include('inc', 'registration', 'includes/registration.admin');
+  }
   $type = $form['#node_type']->type;
 
   $form['registration'] = array(
@@ -183,95 +267,315 @@ function registration_form_node_type_form_alter(&$form, &$form_state) {
     '#collapsible' => TRUE,
     '#collapsed' => FALSE,
   );
-
-  $form['registration']['registration_node_status'] = array(
+  $form['registration']['registration_status:node:'] = array(
     '#type' => 'checkbox',
     '#title' => t('Enable registrations for this content type'),
-    '#default_value' => variable_get('registration_node_status_' . $type, 0),
-    '#description' => t('If enabled, users will be allowed to register for this 
-      content type unless an administrator disbles registrations on specific 
+    '#default_value' => variable_get('registration_status:node:_' . $type, 0),
+    '#description' => t('If enabled, users will be allowed to register for this
+      content type unless an administrator disbles registrations on specific
       posts.'),
   );
+  $form['registration']['registration_bundle:node:'] = array(
+    '#type' => 'select',
+    '#title' => t('Registration Type'),
+    '#default_value' => variable_get('registration_bundle:node:_' . $type, ''),
+    '#options' => registration_bundle_options(),
+  );
+}
+
+/**
+ * Updates the registration settings for the entity.
+ *
+ * @param $entity
+ *   Fully formed entity object.
+ * @param $type
+ *   String of the entity type (not bundle).
+ */
+function registration_entity_submit($entity, $type) {
+  $entity_info = entity_get_info($type);
+  if (isset($entity->registration_status) && $entity->registration_status == 1) {
+    $settings = array(
+      'registration_bundle' => $entity->registration_bundle,
+      'settings' => serialize(registration_default_settings()),
+    );
+    $info = array(
+      'id' => $entity->$entity_info['entity keys']['id'],
+      'type' => $type,
+      'bundle' => $entity->type,
+    );
+    registration_update_entity_settings($info, $settings);
+  }
+}
+
+/**
+ * Implements hook_entity_insert().
+ */
+function registration_entity_insert($entity, $type) {
+  registration_entity_submit($entity, $type);
+}
+
+/**
+ * Implements hook_entity_update().
+ */
+function registration_entity_update($entity, $type) {
+  registration_entity_submit($entity, $type);
+}
+
+/**
+ * Implements hook_form_alter().
+ */
+function registration_form_alter(&$form, &$form_state, $form_id) {
+  if (!function_exists('registration_bundle_options')) {
+    module_load_include('inc', 'registration', 'includes/registration.admin');
+  }
+  $node_types = node_type_get_types();
+  foreach ($node_types as $type => $info) {
+    if ($form_id == $type . '_node_form') {
+      $data = entity_extract_ids('node', $form_state['node']);
+      $entity_info = array(
+        'type' => 'node',
+        'bundle' => $data[2],
+        'id' => $data[0],
+      );
+      $form['registration'] = array(
+        '#type' => 'fieldset',
+        '#title' => t('Registration Settings'),
+        '#collapsible' => TRUE,
+        '#collapsed' => FALSE,
+        '#group' => 'additional_settings',
+      );
+      $form['registration']['registration_status'] = array(
+        '#type' => 'checkbox',
+        '#title' => t('Enable registrations for this node'),
+        '#default_value' => registration_entity_registration_status($entity_info),
+        '#description' => t('If enabled, users will be allowed to register for this
+          node.'),
+      );
+      $form['registration']['registration_bundle'] = array(
+        '#type' => 'select',
+        '#title' => t('Registration Type'),
+        '#default_value' => registration_entity_registration_bundle($entity_info),
+        '#options' => registration_bundle_options(),
+      );
+    }
+  }
+}
+
+/**
+ * Returns the number of slots available for the given entity.
+ *
+ * @param $entity
+ *   Associate array of entity identifying data.
+ *   Allowed keys are:
+ *     id, type, bundle
+ */
+function registration_entity_slots_available($entity) {
+  $capacity = registration_entity_settings($entity);
+  $capacity = $capacity['capacity'];
+  $result = db_select('registration', 'r')
+    ->fields('r')
+    ->condition('entity_type', $entity['type'])
+    ->condition('entity_bundle', $entity['bundle'])
+    ->condition('eid', $entity['id'])
+    ->condition('status', 1)
+    ->execute()
+    ->rowCount();
+  $available = 0;
+  if ($result > $capacity) {
+    return 0;
+  }
+  else {
+    return $capacity - $result;
+  }
+}
+
+/**
+ * Returns the registration bundle for this particular entity.
+ *
+ * @param $entity
+ *   Associate array of entity identifying data.
+ *   Allowed keys are:
+ *     id, type, bundle
+ */
+function registration_entity_registration_bundle($entity, $check_global = TRUE) {
+  if (!isset($entity['id'])) {
+    $entity['id'] = 0;
+  }
+  $q = db_select('registration_attach', 'ra')
+    ->fields('ra', array('registration_bundle'))
+    ->condition('entity_type', $entity['type'])
+    ->condition('entity_bundle', $entity['bundle'])
+    ->condition('entity_id', $entity['id'])
+    ->execute()
+    ->fetchCol();
+  if (count($q) == 0) {
+    if ($entity['id'] != 0 && $check_global) {
+      // No settings found on a per-entity basis, check global entity settings
+      unset($entity['id']);
+      return registration_entity_registration_bundle($entity);
+    }
+    return '';
+  }
+  return $q[0];
+}
+
+/**
+ * Returns the registration status for this particular entity.
+ *
+ * @param $entity
+ *   Associate array of entity identifying data.
+ *   Allowed keys are:
+ *     id, type, bundle
+ */
+function registration_entity_registration_status($entity, $check_global = TRUE) {
+  if (!isset($entity['id'])) {
+    $entity['id'] = 0;
+  }
+  $q = db_select('registration_attach', 'ra')
+    ->fields('ra', array('settings'))
+    ->condition('entity_type', $entity['type'])
+    ->condition('entity_bundle', $entity['bundle'])
+    ->condition('entity_id', $entity['id'])
+    ->execute()
+    ->fetchCol();
+  if (count($q) == 0) {
+    if ($entity['id'] != 0 && $check_global) {
+      // No settings found on a per-entity basis, check global entity settings
+      unset($entity['id']);
+      return registration_entity_registration_status($entity);
+    }
+    return 0;
+  }
+  $settings = $q[0];
+  if (!is_array($settings)) {
+    $settings = unserialize($settings);
+  }
+  return $settings['status'];
 }
 
 /**
  * Implements hook_node_type_delete().
+ * @todo Delete registrations that belong to this node type.
  */
 function registration_node_type_delete($info) {
-  variable_del('registration_node_status' . $info->type);
+  
 }
 
 /**
  * Access callback for registration_register_page().
  */
 function registration_register_page_access($node) {
-  $ret = FALSE;
-  if (variable_get('registration_node_status_' . $node->type, 0)) {
+  $entity = array(
+    'id' => $node->nid,
+    'type' => 'node',
+    'bundle' => $node->type,
+  );
+  if (registration_entity_registration_status($entity)) {
     if (user_access('administer registration') || user_access('add registration')) {
-      $settings = registration_node_settings($node->nid);
-      if ($settings['status']) {
-        $ret = TRUE;
-      }
+      return TRUE;
     }
   }
-
-  return $ret;
+  return FALSE;
 }
 
 /**
  * Access callback for registration_registrations_page().
  */
 function registration_administer_registrations_access($node) {
-  $ret = FALSE;
-  if (variable_get('registration_node_status_' . $node->type, 0)) {
+  $entity = array(
+    'id' => $node->nid,
+    'type' => 'node',
+    'bundle' => $node->type,
+  );
+  if (registration_entity_registration_status($entity)) {
     if (user_access('administer registration')) {
-      $ret = TRUE;
+      return TRUE;
     }
   }
-
-  return $ret;
+  return FALSE;
 }
 
 /**
  * Page callback for adding a registration.
+ *
+ * @TODO Get registration bundle type to create for this entity.
  */
-function registration_register_page($node) {
-  if (registration_has_room($node->nid)) {
-    $registration = entity_get_controller('registration')->create(array('type' => 'registration'));
-    $registration->nid = $node->nid;
-    return drupal_get_form('registration_form', $registration);
+function registration_register_page($entity, $type) {
+  $data = entity_extract_ids($type, $entity);
+  $ent = array(
+    'id' => $data[0],
+    'type' => $type,
+    'bundle' => $data[2],
+  );
+  if (registration_has_room($ent)) {
+    $bundle = registration_entity_registration_bundle($ent);
+    $registration = entity_create('registration', array('type' => $bundle));
+    return drupal_get_form('registration_form', $registration, $entity, $type);
   }
   else {
-    return t('Sorry, %name is sold out', array('%name' => $node->title));
+    return t('Sorry, %name is sold out', array('%name' => $entity->title));
   }
 }
 
 /**
  * Page callback for viewing registrations
+ *
+ * @TODO Switch to entities and field values for items.
  */
-function registration_registrations_page($node) {
+function registration_registrations_page($entity) {
   $header = array(
-    array('data' => t('id'), 'field' => 'registration_id', 'type' => 'property', 
-        'specifier' => 'registration_id'),
-    array('data' => t('Email'), 'field' => 'mail', 'type' => 'property', 
-        'specifier' => 'mail'),
-    array('data' => t('Created By'), 'field' => 'author_uid', 
-        'type' => 'property', 'specifier' => 'author_uid'),
-    array('data' => t('Count'), 'field' => 'count', 'type' => 'property', 
-        'specifier' => 'count'),
-    array('data' => t('Created'), 'field' => 'created', 'sort' => 'desc', 
-        'type' => 'property', 'specifier' => 'created'),
-    array('data' => t('Actions')),
+    array(
+      'data' => t('id'),
+      'field' => 'registration_id',
+      'type' => 'property',
+      'specifier' => 'registration_id',
+    ),
+    array(
+      'data' => t('Email'),
+      'field' => 'mail',
+      'type' => 'property',
+      'specifier' => 'mail',
+    ),
+    array(
+      'data' => t('Created By'),
+      'field' => 'author_uid',
+      'type' => 'property',
+      'specifier' => 'author_uid',
+    ),
+    array(
+      'data' => t('Count'),
+      'field' => 'count',
+      'type' => 'property',
+      'specifier' => 'count',
+    ),
+    array(
+      'data' => t('Created'),
+      'field' => 'created',
+      'sort' => 'desc',
+      'type' => 'property',
+      'specifier' => 'created',
+    ),
+    array(
+      'data' => t('Actions'),
+    ),
+  );
+
+  $data = entity_extract_ids($entity->type, $entity);
+  $ent = array(
+    'id' => $data[0],
+    'type' => $entity->type,
+    'bundle' => $data[2],
   );
-  
   $query = new EntityFieldQuery;
   $result = $query
     ->entityCondition('entity_type', 'registration')
-    ->propertyCondition('nid', $node->nid)
+    ->propertyCondition('eid', $data[0])
+    ->propertyCondition('entity_type', $entity->type)
+    ->propertyCondition('entity_bundle', $data[2])
     ->pager(20)
     ->tableSort($header)
     ->execute();
-    
+
   if (!empty($result['registration'])) {
     $registrations = registration_load_multiple(array_keys($result['registration']));
 
@@ -287,9 +591,11 @@ function registration_registrations_page($node) {
         l('Edit', 'registration/' . $registration->registration_id . '/edit'),
         l('Delete', 'registration/' . $registration->registration_id . '/delete'),
       );
+      $email = entity_metadata_wrapper('registration', $registration);
+      $email = $email->field_email->value();
       $rows[] = array(
         l($registration->registration_id, 'registration/' . $registration->registration_id),
-        l($registration->mail, 'mailto:' . $registration->mail),
+        l($email, 'mailto:' . $email),
         $author,
         $registration->count,
         format_date($registration->created),
@@ -297,122 +603,140 @@ function registration_registrations_page($node) {
       );
     }
 
-    $settings = registration_node_settings($node->nid);
-        
+    $settings = registration_entity_settings($ent);
+
     $table = array(
       'header' => $header,
       'rows' => $rows,
-      'caption' => t('List of registrations for %title. !count of !capacity slots are filled.', 
+      'caption' => t('List of registrations for %title. !count of !capacity slots are filled.',
         array(
-          '%title' => $node->title,
-          '!count' => '<strong>' . registration_event_count($node->nid) . '</strong>', 
-          '!capacity' => '<strong>' . $settings['capacity'] . '</strong>'
-        ))
+          '%title' => $entity->title,
+          '!count' => '<strong>' . registration_event_count($ent) . '</strong>',
+          '!capacity' => '<strong>' . $settings['capacity'] . '</strong>',
+        )
+      ),
     );
 
     $out = theme('table', $table) . theme('pager');
   }
   else {
-    $out = t('There are no registratrants for %name', 
-        array('%name' => $node->title));
+    $out = t('There are no registratrants for %name',
+      array('%name' => $entity->title));
   }
 
   return $out;
 }
 
 /**
- * Helper to determine if a node has any slots left.
+ * Helper to determine if an entity has any slots left.
  */
-function registration_has_room($nid) {
-  $ret      = TRUE;
-  $settings = registration_node_settings($nid);
+function registration_has_room($entity) {
+  $settings = registration_entity_settings($entity);
   $capacity = $settings['capacity'];
   if ($capacity) {
-    $count = registration_event_count($nid);
+    $count = registration_event_count($entity);
     if (($capacity - $count) < 1) {
-      $ret = FALSE;
+      return FALSE;
     }
   }
-
-  return $ret;
+  return TRUE;
 }
 
 /**
- * Return the number of registrations for a given node.
+ * Return the number of registrations for a given entity.
  *
- * @param int $nid
+ * @param $entity
  *
  * @return int
  */
-function registration_event_count($nid) {
+function registration_event_count($entity) {
   $count = &drupal_static(__FUNCTION__, FALSE);
   if (!$count) {
-    $count = db_query("SELECT sum(count) FROM {registration} WHERE nid = :nid",
-      array(':nid' => $nid)
-    )->fetchField();    
+    if (!isset($entity['id'])) {
+      $entity['id'] = 0;
+    }
+    $count = db_select('registration', 'r')
+      ->fields('r')
+      ->condition('entity_type', $entity['type'])
+      ->condition('entity_bundle', $entity['bundle'])
+      ->condition('eid', $entity['id'])
+      ->execute()->rowCount();
   }
   return $count;
 }
 
 /**
+ * Implements hook_entity_delete().
+ */
+function registration_entity_delete($entity, $type) {
+  // Notify field API that this entity was deleted.
+  field_attach_delete($type, $entity);
+  // Get some more info on this entity.
+  $data = entity_extract_ids($type, $entity);
+  // Delete all registrations attached to this entity.
+  db_delete('registration')
+    ->condition('eid', $data[0])
+    ->condition('entity_type', $type)
+    ->condition('entity_bundle', $data[2])
+    ->execute();
+  // Delete all registration settings for this entity.
+  db_delete('registration_attach')
+    ->condition('entity_id', $data[0])
+    ->condition('entity_type', $type)
+    ->condition('entity_bundle', $data[2])
+    ->execute();
+}
+
+/**
  * Implements hook_node_delete().
- *   Delete registrations and settings for this node.
+ *
+ * Deletes registrations and settings for this node.
  */
 function registration_node_delete($node) {
-  db_delete('registration')->condition('nid', $node->nid)->execute();
-  db_delete('registration_node')->condition('nid', $node->nid)->execute();
+  db_delete('registration')
+    ->condition('entity_type', 'node')
+    ->condition('entity_bundle', $node->type)
+    ->condition('eid', $node->nid)
+    ->execute();
+  db_delete('registration_attach')
+    ->condition('entity_id', $node->nid)
+    ->condition('entity_type', 'node')
+    ->condition('entity_bundle', $node->type)
+    ->execute();
 }
 
 /**
- * Return all registration settings for a given node.
+ * Return all registration settings for a given entity.
  *
- * @param string $nid
+ * @param $entity
  *
  * @return array
  */
-function registration_node_settings($nid) {
+function registration_entity_settings($entity) {
   // @TODO: Add static variable handling.
-  $result = db_select('registration_node', 'rn')
-    ->fields('rn')
-    ->condition('nid', $nid, '=')
+  if (!isset($entity['id'])) {
+    $entity['id'] = 0;
+  }
+  $result = db_select('registration_attach', 'ra')
+    ->fields('ra')
+    ->condition('entity_id', $entity['id'])
+    ->condition('entity_type', $entity['type'])
+    ->condition('entity_bundle', $entity['bundle'])
     ->execute()
     ->fetchAssoc();
-
   if ($result) {
-    $result['settings'] = unserialize($result['settings']);   
+    if (!is_array($result['settings'])) {
+      $result['settings'] = unserialize($result['settings']);
+    }
+    return $result['settings'];
   }
-  
-  return $result;
-}
-
-/**
- * Implements hook_theme().
- */
-function registration_theme() {
-  return array(
-    'registration' => array(
-      'arguments' => array('registration' => NULL),
-    ),
-  );
-}
-
-/**
- * Theme handler for registrations.
- *
- * @param array $variables
- *   Contains a complete registration object.
- */
-function theme_registration($variables) {
-  $registration = $variables['registration'];
-  $output = '<div><label>' . t('Email') . '</label>' . $registration->mail . '</div>';
-  if ($node = node_load($registration->nid)) {
-    $output .= '<div><label>' . $node->type . "</label>" . l($node->title, 'node/' . $registration->nid) . '</div>';
+  if ($entity['id'] != 0) {
+    $entity['id'] = 0;
+    return registration_entity_settings($entity);
+  }
+  else {
+    return array();
   }
-
-  $output .= '<div><label>' . t('Count') . '</label>' . $registration->count . '</div>';
-  $output .= '<div><label>' . t('Created') . '</label>' . format_date($registration->created) . '</div>';
-
-  return $output;
 }
 
 /**
@@ -426,23 +750,30 @@ function registration_mail($key, &$message, $params) {
 }
 
 /**
- * Send an email to all registrations for a given node.
+ * Send an email to all registrations for a given entity.
  *
  * @param object $node
  */
-function registration_send_broadcast($node, $subject, $message) {
+function registration_send_broadcast($entity, $subject, $message) {
   global $language;
-  
+
   // grab registration node settings
-  $settings = registration_node_settings($node->nid);
+  $data = entity_extract_ids($entity->type, $entity);
+  $ent = array(
+    'id' => $data[0],
+    'type' => $entity->type,
+    'bundle' => $data[2],
+  );
+  $settings = registration_entity_settings($ent);
   $from = $settings['settings']['from_address'];
-  
+
   // grab all registrations
   $query = new EntityFieldQuery();
   $entities = $query
     ->entityCondition('entity_type', 'registration')
-    ->entityCondition('bundle', 'registration')
-    ->propertyCondition('nid', $node->nid)
+    ->propertyCondition('entity_type', $entity->type)
+    ->propertyCondition('entity_bundle', $data[2])
+    ->propertyCondition('eid', $data[0])
     ->execute();
 
   if (!empty($entities)) {
@@ -461,6 +792,7 @@ function registration_send_broadcast($node, $subject, $message) {
     // send the email to each registrant and communicate results
     $success_count = 0;
     foreach ($registrations as $registration) {
+      // @TODO Get email address from field value
       $recipients[] = $registration->mail;
       $result = drupal_mail('registration', 'broadcast',
         $registration->mail, $language, $params, $from
@@ -486,60 +818,102 @@ function registration_send_broadcast($node, $subject, $message) {
   }
   else {
     drupal_set_message(
-      t('There are no participants registered for this %type.', 
-          array('%type' => $node->type)),
+      t('There are no participants registered for this %type.',
+          array('%type' => $entity->type)),
       $type = 'warning'
     );
   }
 }
 
 /**
- * Update a node's registration settings.
+ * Update an entity's registration settings.
  *
- * @param int $nid 
+ * @param $entity
+ *   Associative array of entity info.
+ *   Keys are id, type and bundle.
  * @param array $settings
- *    Associative array containing additional node registration settings.
- *    Keys are status, capacity, send_reminder, reminder_date, reminder_template
- *    and an associatve array of additional settings.
+ *   Associative array containing additional node registration settings.
+ *   Keys are status, capacity, send_reminder, reminder_date, reminder_template
+ *   and an associatve array of additional settings.
  */
-function registration_update_node_settings($nid, $settings) {
+function registration_update_entity_settings($entity_info, $settings) {
   // insert or udpate registration node settings
-  db_merge('registration_node')
-    ->key(array('nid' => $nid))
+  db_merge('registration_attach')
+    ->key(
+      array(
+        'entity_id' => $entity_info['id'],
+        'entity_type' => $entity_info['type'],
+        'entity_bundle' => $entity_info['bundle']
+      )
+    )
     ->fields($settings)
     ->execute();
 
-  drupal_set_message(t('Registration settings have been saved.'));  
+  drupal_set_message(t('Registration settings have been saved.'));
 }
 
 /**
  * Implements hook_cron().
  */
-function registration_cron() {
+function registration_cron_nope() {
   //@TODO: need to have a sensible batch limit, passed in as a limit param
-  
+
   // grab all registrations that have reminders set for this day
-  $results = db_select('registration_node', 'rn')
-    ->fields('rn')
-    ->condition('send_reminder', 1)
-    ->condition('reminder_date', date('Y-m-d 00:00:00'))
-    ->range(0, 10)
+  $results = db_select('registration', 'r')
+    ->fields('r')
     ->execute()
-    ->fetchAllAssoc('nid');
+    ->fetchAssoc();
 
   foreach ($results as $result) {
-    $node = node_load($result->nid);
-    $message = $result->reminder_template;
+    $ent = array(
+      'id' => $result->eid,
+      'type' => $result->entity_type,
+      'bundle' => $result->entity_bundle,
+    );
+    $entity = entity_get_controller($ent['type'])->load($ent['id']);
+    $entity = $entity[$result->eid];
     if (module_exists('token')) {
-      $message = token_replace($message, array('node' => $node));
+      $message = token_replace($message, array('entity' => $entity));
     }
-    $subject = 'Reminder for ' . $node->title;
-    registration_send_broadcast($node, $subject, $message);
-    
-    // set reminder flag to off
-    db_update('registration_node')
-      ->fields(array('send_reminder' => 0))
-      ->condition('nid', $node->nid)
-      ->execute();
+    $subject = 'Reminder for ' . $entity->title;
+    registration_send_broadcast($entity, $subject, $message);
   }
 }
+
+/**
+ * Implements hook_theme().
+ */
+function registration_theme() {
+  return array(
+    'registration' => array(
+      'arguments' => array('registration' => NULL),
+      'file' => 'includes/registration.theme.inc',
+    ),
+    'registration_types' => array(
+      'arguments' => array('types' => NULL),
+      'file' => 'includes/registration.theme.inc',
+    ),
+  );
+}
+
+/**
+ * Default settings for entity registration.
+ *
+ * @return
+ *  Array of default settings for a new entity registration association.
+ */
+function registration_default_settings() {
+  return array(
+    'capacity' => 0,
+    'status' => 1,
+    // unix timestamp of the closing date, default to one month from now
+    'open_date' => REQUEST_TIME,
+    'close_date' => strtotime('now +1 month'),
+    'reminder' => 1,
+    // reminder_time is set in minutes prior to closing date of registrations
+    // we default 2 reminders to one week and 2 days prior to close
+    'reminder_time' => array(7*24*60, 2*24*60),
+    'notify' => 0,
+    'notify_email' => array(),
+  );
+}
